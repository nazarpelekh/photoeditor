<!doctype html>
<html class="no-js" lang="">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title></title>
  <link rel="stylesheet" href="css/style.css">
  <meta name="description" content="">

  <meta property="og:title" content="">
  <meta property="og:type" content="">
  <meta property="og:url" content="">
  <meta property="og:image" content="">

  <link rel="icon" href="/favicon.ico" sizes="any">
  <link rel="icon" href="/icon.svg" type="image/svg+xml">
  <link rel="apple-touch-icon" href="icon.png">

  <link rel="manifest" href="site.webmanifest">
  <meta name="theme-color" content="#fafafa">

  <!--<style>
    @font-face {
      font-family: 'Plus Jakarta Sans';
      src: url('/fonts/PlusJakartaSans-Regular.woff2') format('woff2'),
      url('/fonts/PlusJakartaSans-Regular.woff') format('woff');
      font-weight: normal;
      font-style: normal;
      font-display: swap;
    }

    @font-face {
      font-family: 'Plus Jakarta Sans';
      src: url('/fonts/PlusJakartaSans-BoldItalic.woff2') format('woff2'),
      url('/fonts/PlusJakartaSans-BoldItalic.woff') format('woff');
      font-weight: bold;
      font-style: italic;
      font-display: swap;
    }

    @font-face {
      font-family: 'Plus Jakarta Sans';
      src: url('/fonts/PlusJakartaSans-Bold.woff2') format('woff2'),
      url('/fonts/PlusJakartaSans-Bold.woff') format('woff');
      font-weight: bold;
      font-style: normal;
      font-display: swap;
    }

    @font-face {
      font-family: 'Plus Jakarta Sans';
      src: url('/fonts/PlusJakartaSans-Italic.woff2') format('woff2'),
      url('/fonts/PlusJakartaSans-Italic.woff') format('woff');
      font-weight: normal;
      font-style: italic;
      font-display: swap;
    }

    @font-face {
      font-family: 'Richmond Text';
      src: url('/fonts/RichmondText-Regular.woff2') format('woff2'),
      url('/fonts/RichmondText-Regular.woff') format('woff');
      font-weight: normal;
      font-style: normal;
      font-display: swap;
    }

    @font-face {
      font-family: 'Richmond Display';
      src: url('/fonts/RichmondDisplay-RegularItalic.woff2') format('woff2'),
      url('/fonts/RichmondDisplay-RegularItalic.woff') format('woff');
      font-weight: normal;
      font-style: italic;
      font-display: swap;
    }

    @font-face {
      font-family: 'Richmond Display';
      src: url('/fonts/RichmondDisplay-Bold.woff2') format('woff2'),
      url('/fonts/RichmondDisplay-Bold.woff') format('woff');
      font-weight: bold;
      font-style: normal;
      font-display: swap;
    }

    @font-face {
      font-family: 'Richmond Display';
      src: url('/fonts/RichmondDisplay-SemiBoldItalic.woff2') format('woff2'),
      url('/fonts/RichmondDisplay-SemiBoldItalic.woff') format('woff');
      font-weight: bold;
      font-style: italic;
      font-display: swap;
    }

    @font-face {
      font-family: 'Playfair Display';
      src: url('/fonts/PlayfairDisplay-BoldItalic.woff2') format('woff2'),
      url('/fonts/PlayfairDisplay-BoldItalic.woff') format('woff');
      font-weight: bold;
      font-style: italic;
      font-display: swap;
    }

    @font-face {
      font-family: 'Playfair Display';
      src: url('/fonts/PlayfairDisplay-Bold.woff2') format('woff2'),
      url('/fonts/PlayfairDisplay-Bold.woff') format('woff');
      font-weight: bold;
      font-style: normal;
      font-display: swap;
    }

    @font-face {
      font-family: 'Playfair Display';
      src: url('/fonts/PlayfairDisplay-Italic.woff2') format('woff2'),
      url('/fonts/PlayfairDisplay-Italic.woff') format('woff');
      font-weight: normal;
      font-style: italic;
      font-display: swap;
    }

    @font-face {
      font-family: 'Playfair Display';
      src: url('/fonts/PlayfairDisplay-Regular.woff2') format('woff2'),
      url('/fonts/PlayfairDisplay-Regular.woff') format('woff');
      font-weight: normal;
      font-style: normal;
      font-display: swap;
    }


  </style>-->

    <link href="https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@400;700&family=Playfair+Display:wght@400;700&family=Richmond+Display:wght@400&display=swap" rel="stylesheet">
</head>

<body>
<!-- Version 4 -->
<form id="imageForm">
  <input type="file" id="uploadImage" accept="image/*">
  <br><br>

  <!-- Output Size Selection -->
  <label>Select Output Size:
    <input type="radio" name="outputSize" value="1920x1080"> 1920 x 1080
  </label>
  <label>
    <input type="radio" name="outputSize" value="1080x1080" checked> 1080 x 1080
  </label>
  <br><br>

  <!-- Mode selector for choosing between Text and Blur Area -->
  <label>
    <input type="radio" name="mode" value="text" checked> Text Mode
  </label>
  <label>
    <input type="radio" name="mode" value="blur"> Blur Area Mode
  </label>
  <label>
    <input type="radio" name="mode" value="logo"> Logo Mode
  </label>
  <label>
    <input type="radio" name="mode" value="figure"> Figure Mode
  </label>
  <br><br>

  <div id="text-mode" class="mode-elements">
    <!-- Input for custom text -->
    <textarea id="customTextEditor"></textarea>
    <br><br>


  </div>

  <div id="blur-mode" class="mode-elements" style="display: none">
    <label for="blurStrength">Blur Strength:</label>
    <input type="range" id="blurStrength" min="0" max="30" value="0">
    <br><br>

    <label for="contrastRange">Contrast:</label>
    <input type="range" id="contrastRange" min="-100" max="100" value="0">
    <span id="contrastValue">0</span>
    <br><br>

    <label>Select overlay images:</label>
    <br>
    <div style="display:flex; align-items: center; gap: 10px">
      <label>
        <input type="checkbox" name="overlayImage" value="image1">
        <img src="./img/GRAIN-1.jpg" width="20" height="20" alt="">
        <br>
        <input type="range" id="image1Opacity" min="0" max="100" value="20"> Opacity
      </label>
      <label>
        <input type="checkbox" name="overlayImage" value="image2">
        <img src="./img/GRAIN-2.jpg" width="20" height="20" alt="">
        <br>
        <input type="range" id="image2Opacity" min="0" max="100" value="20"> Opacity
      </label>
      <label>
        <input type="checkbox" name="overlayImage" value="image3">
        <img src="./img/GRAIN-3.jpg" width="20" height="20" alt="">
        <br>
        <input type="range" id="image3Opacity" min="0" max="100" value="20"> Opacity
      </label>
      <label>
        <input type="checkbox" name="overlayImage" value="image4">
        <img src="./img/GRADIENT.jpg" width="20" height="20" alt="">
        <br>
        <input type="range" id="image4Opacity" min="0" max="100" value="20"> Opacity
      </label>
      <label>
        <input type="checkbox" name="overlayImage" value="image5">
        <img src="./img/GRADIENT-1.jpg" width="20" height="20" alt="">
        <br>
        <input type="range" id="image5Opacity" min="0" max="100" value="20"> Opacity
      </label>
      <label>
        <input type="checkbox" name="overlayImage" value="image6">
        <img src="./img/GRADIENT-4.jpg" width="20" height="20" alt="">
        <br>
        <input type="range" id="image6Opacity" min="0" max="100" value="20"> Opacity
      </label>
    </div>
    <br><br>
  </div>

  <div id="figure-mode" class="mode-elements" style="display:none;">
    <h3>Select a Figure:</h3>
    <label>
      <input type="radio" name="figure" value="noFigure" checked> No Figure
    </label>
    <label>
      <input type="radio" name="figure" value="figure1"> Figure 1
    </label>
    <label>
      <input type="radio" name="figure" value="figure2"> Figure 2
    </label>
    <label>
      <input type="radio" name="figure" value="figure3"> Figure 3
    </label>
    <br><br>

    <!-- Scale Range Input -->
    <div>
      <label for="figureScale">Scale Figure:</label>
      <input type="range" id="figureScale" name="figureScale" min="0.5" max="5" step="0.1" value="1">
      <span id="figureScaleValue">1x</span>
    </div>
  </div>


  <div id="logo-mode" class="mode-elements" style="display:none;">
    <div>
      <h3>Select a Logo:</h3>
      <label>
        <input type="radio" name="staticLogo" value="noLogo" checked> NO LOGO
      </label>
      <label>
        <input type="radio" name="staticLogo" value="logo1"> Logo 1
      </label>
      <label>
        <input type="radio" name="staticLogo" value="logo2"> Logo 2
      </label>
      <label>
        <input type="radio" name="staticLogo" value="logo3"> Logo 3
      </label>
      <label>
        <input type="file" id="uploadLogo" accept="image/*"> Upload Custom Logo
      </label>
    </div>

    <br>

    <!-- Logo position selection -->
    <label for="logoPosition">Select Logo Position:</label>
    <select id="logoPosition">
      <option value="top-left">Top Left</option>
      <option value="top-right">Top Right</option>
      <option value="bottom-left">Bottom Left</option>
      <option value="bottom-right">Bottom Right</option>
      <option value="center">Center</option>
    </select>
    <br><br>
  </div>

  <canvas id="imageCanvas" style="display:none;"></canvas>
  <br>
  <button type="button" id="downloadButton" style="display:none;">Download Processed Image</button>
</form>

<script src="https://cdn.tiny.cloud/1/hw35wh74adbpr4x0uc9ngxdc8yxqbh0uazjhujo98kaqrou9/tinymce/7/tinymce.min.js" referrerpolicy="origin"></script>
<script>
  const canvas = document.getElementById('imageCanvas');

  let img = null,
    overlayImg = new Image(),
    isDrawing = false;
  let logoImg;
  let startX, startY, rectWidth, rectHeight;
  let blurArea = { x: 0, y: 0, width: 0, height: 0 };
  let textPosition = { x: 0, y: 0 }; // Default to center
  let fontColor = '#ffffff'; // Default font color
  let mode = 'text'; // Default mode is text positioning
  let overlayImageSelection = 'image1'; // Default overlay image
  let contrastValue = 0; // Default contrast value

  let overlayImages = {};  // Store overlay images here
  let overlayImageOpacity = { image1: 0.2, image2: 0.2, image3: 0.2, image4: 0.2, image5: 0.2, image6: 0.2 }; // Default opacity for each image
  let staticOverlayImages = {
    image1: './img/GRAIN-1.jpg',
    image2: './img/GRAIN-2.jpg',
    image3: './img/GRAIN-3.jpg',
    image4: './img/GRADIENT.jpg',
    image5: './img/GRADIENT-1.jpg',
    image6: './img/GRADIENT-4.jpg',
  }

  const staticLogos = {
    logo1: './img/logo.svg',
    logo2: './img/logo-black.svg',
    logo3: './img/logo-white.svg',
  }
  let uploadedLogo = null;

  let selectedFigure = null;
  let figurePosition = { x: 0.5, y: 0.5 };
  let isFigureSelected = false;

  const figures = {
    figure1: './img/Layer_1.svg',
    figure2: './img/Layer_1.svg',
    figure3: './img/Layer_1.svg'
  };
  let figureScale = 1;

  // Get references to the scale input and display elements
  const figureScaleInput = document.getElementById('figureScale');
  const figureScaleValueDisplay = document.getElementById('figureScaleValue');

  let outputSize = document.querySelector('input[name="outputSize"]:checked').value; // Default output size
  let previousOutputSize = outputSize; // Keep track of the previous output size

  // Add event listeners to update the output size when the user changes the selection
  document.querySelectorAll('input[name="outputSize"]').forEach((radio) => {
    radio.addEventListener('change', function() {
      const newSize = this.value;

      // If an image is uploaded, check if it meets the minimum size for the new mode
      if (img) {
        let minWidth, minHeight;
        if (newSize === '1920x1080') {
          minWidth = 1920;
          minHeight = 1080;
        } else if (newSize === '1080x1080') {
          minWidth = 1080;
          minHeight = 1080;
        }

        if (img.width < minWidth || img.height < minHeight) {
          alert(`Cannot change to ${newSize} mode. The uploaded image is smaller than ${minWidth}x${minHeight}px.`);
          // Revert the selection back to the previous output size
          document.querySelector(`input[name="outputSize"][value="${previousOutputSize}"]`).checked = true;
          return;
        }
      }

      // If no image is uploaded or the image is large enough, proceed
      outputSize = newSize; // Update the output size
      previousOutputSize = newSize; // Update the previous output size
      renderImageWithBlur(); // Re-render the image with new output size
    });
  });

  // Handle positioning the figure when in "Figure Mode"
  canvas.addEventListener('click', function(event) {
    if (mode === 'figure' && isFigureSelected) {
      const rect = canvas.getBoundingClientRect();
      figurePosition.x = event.clientX - rect.left;
      figurePosition.y = event.clientY - rect.top;
      renderImageWithBlur(); // Redraw the canvas with the new figure position
    }
  });

  // Event listener for figure selection
  document.querySelectorAll('input[name="figure"]').forEach((radio) => {
    radio.addEventListener('change', function() {
      const selectedFigureKey = this.value;
      if (selectedFigureKey === 'noFigure') {
        // If "No Figure" is selected
        selectedFigure = null;
        isFigureSelected = false;
        renderImageWithBlur(); // Redraw the canvas without the figure
      } else {
        // Load the selected figure
        selectedFigure = new Image();
        selectedFigure.src = figures[selectedFigureKey];
        isFigureSelected = true; // Enable figure positioning
        selectedFigure.onload = function() {
          renderImageWithBlur(); // Redraw with the new figure
        };
      }
    });
  });

  // Event listener for figure scaling
  figureScaleInput.addEventListener('input', function() {
    console.log(this.value)
    figureScale = parseFloat(this.value);
    figureScaleValueDisplay.textContent = `${figureScale}x`;
    if (isFigureSelected && selectedFigure) {
      renderImageWithBlur(); // Redraw the canvas with the new scale
    }
  });

  // Add event listener for static logo selection
  document.querySelectorAll('input[name="staticLogo"]').forEach((radio) => {
    radio.addEventListener('change', function() {
      uploadedLogo = null; // Clear the uploaded logo when a static logo is selected
      renderImageWithBlur(); // Re-render the image
    });
  });

  // Handle the logo upload
  document.getElementById('uploadLogo').addEventListener('change', function(event) {
    const file = event.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = function(e) {
      uploadedLogo = new Image();
      uploadedLogo.onload = function() {
        // Reset static logo selection to "NO LOGO"
        document.querySelector('input[name="staticLogo"][value="noLogo"]').checked = true;
        renderImageWithBlur(); // Render the image with the uploaded logo
      };
      uploadedLogo.src = e.target.result;
    };
    reader.readAsDataURL(file);
  });


  // Handle the checkbox selections for overlay images
  document.querySelectorAll('input[name="overlayImage"]').forEach(checkbox => {
    checkbox.addEventListener('change', function() {
      const selectedImage = checkbox.value;

      if (checkbox.checked) {
        // Load the overlay image and store it in the overlayImages object
        const overlayImg = new Image();
        overlayImg.src = staticOverlayImages[selectedImage];
        overlayImg.onload = function() {
          overlayImages[selectedImage] = overlayImg;
          renderImageWithBlur();  // Re-render with the new overlay
        };
      } else {
        // Remove the image from the overlayImages object
        delete overlayImages[selectedImage];
        renderImageWithBlur();  // Re-render without the overlay
      }
    });
  });

  // Initialize TinyMCE
  tinymce.init({
    selector: '#customTextEditor',
    setup: function (editor) {
      editor.on('input change', function () {
        renderImageWithBlur();
      });
    },
    block_formats: 'Paragraph=p; Header 1=h1; Header 2=h2; Header 3=h3',
    toolbar: 'undo redo | h1 h2 h3 h4 h5 | bold italic | forecolor | fontfamily fontsize ' , // could add fontsizeinput instead of fontsize
    menubar: false,
    font_family_formats: 'Arial=arial,helvetica,sans-serif; Plus Jakarta Sans=Plus Jakarta Sans, sans-serif; Richmond Display=Richmond Display, serif; Playfair Display=Playfair Display, serif;',
    default_font_stack: ['Arial'],
    font_size_formats: '12px 14px 16px 18px 20px 24px 28px 32px 36px 48px 64px 72px',
    content_style: 'body { background-color: #f0f0f0; }',
    height: 200,
  });

  // // Handle checkbox selection for overlay images
  // document.querySelectorAll('input[name="overlayImage"]').forEach((checkbox) => {
  //   checkbox.addEventListener('change', function() {
  //     renderImageWithBlur(); // Re-render the image when any checkbox is toggled
  //   });
  // });

  function drawText(ctx) {
    // Get the HTML content from TinyMCE
    const customTextHTML = tinymce.get('customTextEditor').getContent();

    if (customTextHTML) {
      // Create a temporary DOM element to parse the HTML content
      const tempDiv = document.createElement('div');
      tempDiv.innerHTML = customTextHTML;

      // Adjust positions if using ratios
      let x = textPosition.x * canvas.width;
      let y = textPosition.y * canvas.height;

      // Set text alignment and baseline
      ctx.textAlign = 'left'; // Align text starting from the x position
      ctx.textBaseline = 'top'; // Text starts from the y position

      // Start rendering from the root node
      renderNode(ctx, tempDiv, x, y, x, true);
    }
  }


  function renderNode(ctx, node, x, y, initialX, isFirstBlock, parentStyle = {}) {
    let currentX = x;
    let currentY = y;

    if (node.nodeType === Node.TEXT_NODE) {
      const text = node.textContent;

      if (text.trim() !== '') {
        // Get the computed style for this text node, merging with parent styles
        const computedStyle = getComputedStyleForNode(node.parentNode, parentStyle);

        // Set font properties
        ctx.font = computedStyle.font;
        ctx.fillStyle = computedStyle.color;

        // Measure the text width
        const textMetrics = ctx.measureText(text);

        // Draw the text
        ctx.fillText(text, currentX, currentY);

        // Handle text decoration (e.g., underline)
        if (computedStyle.textDecoration.includes('underline')) {
          ctx.beginPath();
          const textHeight = parseInt(computedStyle.fontSize, 10);
          ctx.moveTo(currentX, currentY + textHeight);
          ctx.lineTo(currentX + textMetrics.width, currentY + textHeight);
          ctx.strokeStyle = computedStyle.color;
          ctx.lineWidth = 1;
          ctx.stroke();
        }

        // Update currentX for the next text segment
        currentX += textMetrics.width;
      }
    } else if (node.nodeType === Node.ELEMENT_NODE) {
      // Save the current context state
      ctx.save();

      // Get the computed style for this element, merging with parent styles
      const computedStyle = getComputedStyleForNode(node, parentStyle);

      // Apply font properties
      ctx.font = computedStyle.font;
      ctx.fillStyle = computedStyle.color;

      // Handle block-level elements
      if (['P', 'DIV', 'BR', 'H1', 'H2', 'H3', 'H4', 'H5'].includes(node.nodeName)) {
        if (!isFirstBlock) {
          const fontSizeInPx = parseInt(computedStyle.fontSize, 10);
          currentY += fontSizeInPx * 1.2; // Move y position down for new block
        }
        currentX = initialX; // Reset x to the initial x position

        isFirstBlock = false; // After processing the first block, set to false
      }

      // Render child nodes
      node.childNodes.forEach(child => {
        const result = renderNode(ctx, child, currentX, currentY, initialX, isFirstBlock, computedStyle);
        currentX = result.x;
        currentY = result.y;
        // Do not update isFirstBlock to maintain correct behavior
      });

      // Restore the context state
      ctx.restore();
    }

    return { x: currentX, y: currentY };
  }



  function getComputedStyleForNode(node, parentStyle = {}) {
    let fontStyle = parentStyle.fontStyle || '';
    let fontWeight = parentStyle.fontWeight || '';
    let nodeFontFamily = parentStyle.fontFamily || 'Arial'; // Default font family
    let nodeFontSize = parentStyle.fontSize || '16px'; // Default font size
    let color = parentStyle.color || '#000000'; // Default font color
    let textDecoration = parentStyle.textDecoration || '';

    // Check for inline styles or attributes
    if (node.style) {
      if (node.style.fontStyle) {
        fontStyle = node.style.fontStyle;
      }
      if (node.style.fontWeight) {
        fontWeight = node.style.fontWeight;
      }
      if (node.style.fontFamily) {
        nodeFontFamily = node.style.fontFamily;
      }
      if (node.style.fontSize) {
        nodeFontSize = node.style.fontSize;
      }
      if (node.style.color) {
        color = node.style.color;
      }
      if (node.style.textDecoration) {
        textDecoration = node.style.textDecoration;
      }
    }

    // Check for bold, italic, underline tags
    if (node.nodeName === 'B' || node.nodeName === 'STRONG') {
      fontWeight = 'bold';
    }
    if (node.nodeName === 'I' || node.nodeName === 'EM') {
      fontStyle = 'italic';
    }
    if (node.nodeName === 'U') {
      textDecoration = 'underline';
    }

    // Handle header tags with default sizes if not set
    if (['H1', 'H2', 'H3', 'H4', 'H5'].includes(node.nodeName)) {
      if (!node.style.fontSize) {
        const headerSizes = {
          H1: '32px',
          H2: '28px',
          H3: '24px',
          H4: '20px',
          H5: '16px',
        };
        nodeFontSize = headerSizes[node.nodeName];
      }
      fontWeight = 'bold';
    }

    // Construct the font property
    const font = `${fontStyle} ${fontWeight} ${nodeFontSize} ${nodeFontFamily}`;

    return {
      font,
      color,
      textDecoration,
      fontSize: nodeFontSize,
      fontFamily: nodeFontFamily,
      fontWeight,
      fontStyle,
    };
  }



  // Function to handle paragraph <p> nodes
  function handleParagraph(ctx, node, x, y) {
    node.childNodes.forEach(childNode => {
      handleInlineText(ctx, childNode, x, y);
      x += ctx.measureText(childNode.textContent).width; // Adjust x position for inline elements
    });
  }

  // Function to handle inline elements (<b>, <i>, <strong>, etc.)
  function handleInlineText(ctx, node, x, y) {
    let fontStyle = '';

    // Determine the font style based on the element type
    if (node.nodeName === 'B' || node.nodeName === 'STRONG') {
      fontStyle = 'bold ';
    } else if (node.nodeName === 'I' || node.nodeName === 'EM') {
      fontStyle = 'italic ';
    }

    // Check if the node has a specific font family set via inline style
    if (node.style && node.style.fontFamily) {
      fontFamily = node.style.fontFamily;
    }

    // Set font and style for canvas rendering
    ctx.font = `${fontStyle}${fontSize}px ${fontFamily}`;
    ctx.fillStyle = fontColor;
    ctx.textAlign = 'left'; // Align left for better flow control

    // Draw the text based on node type (text or element)
    if (node.nodeType === Node.TEXT_NODE) {
      ctx.fillText(node.textContent, x, y);
    } else if (node.nodeType === Node.ELEMENT_NODE) {
      ctx.fillText(node.innerText, x, y);
    }
  }

  let staticImg = new Image();
  staticImg.src = 'https://placehold.co/600x600';

  // Load the uploaded image
  // Load the uploaded image
  document.getElementById('uploadImage').addEventListener('change', function(event) {
    const file = event.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = function(e) {
      const tempImg = new Image();
      tempImg.onload = function() {
        // Check if the image meets the minimum size requirements
        let minWidth, minHeight;
        if (outputSize === '1920x1080') {
          minWidth = 1920;
          minHeight = 1080;
        } else if (outputSize === '1080x1080') {
          minWidth = 1080;
          minHeight = 1080;
        }

        if (tempImg.width < minWidth || tempImg.height < minHeight) {
          alert(`Please upload an image with dimensions at least ${minWidth}x${minHeight}px for the selected mode.`);
          // Clear the file input
          document.getElementById('uploadImage').value = '';
          return;
        }

        // If the image is large enough, proceed to load it
        img = tempImg; // Store the uploaded image
        renderImageWithBlur(); // Initial rendering with the uploaded image
      };
      tempImg.src = e.target.result;
    };
    reader.readAsDataURL(file);
  });

  // Get references to mode radio buttons and the elements to show/hide
  const modeRadios = document.querySelectorAll('input[name="mode"]');

  // Function to update the visibility of elements based on the active mode
  function updateVisibility() {

    const activeMode = document.querySelector('input[name="mode"]:checked').value;

    const modeElements = document.querySelectorAll('.mode-elements');

    modeElements.forEach(element => {
      element.style.display = 'none';
    });

    console.log(activeMode)


    if (document.getElementById(activeMode + '-mode')) {
      document.getElementById(activeMode + '-mode').style.display = 'block';
    }
  }

  // Add event listeners to the mode radio buttons
  modeRadios.forEach(radio => {
    radio.addEventListener('change', updateVisibility);
  });

  // Call the function initially to set the correct visibility when the page loads
  updateVisibility();

  // Mode switcher for toggling between text positioning and blur area mode
  document.querySelectorAll('input[name="mode"]').forEach((radio) => {
    radio.addEventListener('change', function() {
      mode = this.value; // Update the mode based on user selection
    });
  });

  // Handle overlay image selection
  document.querySelectorAll('input[name="overlayImage"]').forEach((radio) => {
    radio.addEventListener('change', function() {
      overlayImageSelection = this.value; // Update the selected image type
      overlayImg.src = overlayImages[overlayImageSelection]; // Load the selected image
      overlayImg.onload = function() {
        renderImageWithBlur(); // Re-render the image with the new overlay
      };
    });
  });

  let blurStrength = 0; // Default blur strength (10px)

  // Capture the value from the blur range input and update the blur strength dynamically
  document.getElementById('blurStrength').addEventListener('input', function() {
    blurStrength = parseInt(this.value); // Update the blur strength based on the range input
    renderImageWithBlur(); // Re-render the canvas with the new blur strength
  });

  // Handle opacity sliders for each overlay image
  document.querySelectorAll('input[type="range"]').forEach(slider => {
    slider.addEventListener('input', function() {
      const imageName = this.id.replace('Opacity', '');
      const opacityValue = parseInt(this.value) / 100;  // Convert to opacity range 0-1
      overlayImageOpacity[imageName] = opacityValue;  // Store the opacity value
      renderImageWithBlur();  // Re-render with updated opacity
    });
  });

  // Function to render the image with a blur, clear area, overlay image, and text
  function renderImageWithBlur() {
    const ctx = canvas.getContext('2d');

    // Determine the target canvas dimensions based on output size
    let targetWidth, targetHeight;
    let aspectRatio;

    if (outputSize === '1920x1080') {
      targetWidth = 1920;
      targetHeight = 1080;
      aspectRatio = 1920 / 1080;
    } else if (outputSize === '1080x1080') {
      targetWidth = 1080;
      targetHeight = 1080;
      aspectRatio = 1;
    }

    // Set canvas dimensions to target dimensions
    canvas.width = targetWidth;
    canvas.height = targetHeight;

    // Clear the canvas
    ctx.clearRect(0, 0, targetWidth, targetHeight);

    // Calculate the scaling factor to fit the uploaded image into the canvas while preserving aspect ratio
    const imgAspectRatio = img.width / img.height;
    let drawWidth, drawHeight, offsetX, offsetY;

    if (imgAspectRatio > aspectRatio) {
      // Image is wider than canvas aspect ratio
      drawHeight = targetHeight;
      drawWidth = img.width * (targetHeight / img.height);
      offsetX = -(drawWidth - targetWidth) / 2;
      offsetY = 0;
    } else {
      // Image is taller than canvas aspect ratio
      drawWidth = targetWidth;
      drawHeight = img.height * (targetWidth / img.width);
      offsetX = 0;
      offsetY = -(drawHeight - targetHeight) / 2;
    }

    // Apply blur and contrast filters
    ctx.filter = `blur(${blurStrength}px) contrast(${100 + contrastValue}%)`;

    // Draw the scaled image onto the canvas
    ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);

    // Reset the filter
    ctx.filter = 'none';

    // Store displayed image dimensions for position calculations
    displayedImage = {
      x: offsetX,
      y: offsetY,
      width: drawWidth,
      height: drawHeight
    };

    // Apply overlays to the blurred background
    for (let key in overlayImages) {
      const overlayImg = overlayImages[key];
      const opacity = overlayImageOpacity[key];
      ctx.globalAlpha = opacity;
      ctx.drawImage(overlayImg, 0, 0, targetWidth, targetHeight);
      ctx.globalAlpha = 1;
    }

    // Draw the figure between blurred and focused areas
    if (selectedFigure) {
      const adjustedFigurePosition = {
        x: figurePosition.x * targetWidth,
        y: figurePosition.y * targetHeight
      };
      drawFigure(ctx, selectedFigure, adjustedFigurePosition);
    }

    // Restore the unblurred region (focused area), if specified
    if (blurArea.width > 0 && blurArea.height > 0) {
      const adjustedBlurArea = {
        x: blurArea.x * targetWidth,
        y: blurArea.y * targetHeight,
        width: blurArea.width * targetWidth,
        height: blurArea.height * targetHeight
      };

      ctx.save();
      ctx.beginPath();
      ctx.rect(adjustedBlurArea.x, adjustedBlurArea.y, adjustedBlurArea.width, adjustedBlurArea.height);
      ctx.clip();

      ctx.filter = `contrast(${100 + contrastValue}%)`;
      ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);
      ctx.filter = 'none';

      // Apply overlays within the unblurred area
      for (let key in overlayImages) {
        const overlayImg = overlayImages[key];
        const opacity = overlayImageOpacity[key];
        ctx.globalAlpha = opacity;
        ctx.drawImage(overlayImg, 0, 0, targetWidth, targetHeight);
        ctx.globalAlpha = 1;
      }

      ctx.restore();
    }

    // Draw the logo
    if (uploadedLogo) {
      drawLogo(ctx, uploadedLogo);
    } else {
      const selectedLogoKey = document.querySelector('input[name="staticLogo"]:checked').value;
      if (selectedLogoKey !== 'noLogo') {
        let selectedLogoSrc = staticLogos[selectedLogoKey];
        const staticLogo = new Image();
        staticLogo.onload = function() {
          drawLogo(ctx, staticLogo);
        };
        staticLogo.src = selectedLogoSrc;
      }
    }

    // Adjust and draw the text
    const adjustedTextPosition = {
      x: textPosition.x * targetWidth,
      y: textPosition.y * targetHeight
    };
    drawText(ctx);

    // Display the canvas and download button
    canvas.style.display = 'block';
    document.getElementById('downloadButton').style.display = 'block';
  }

  function drawFigure(ctx, figureImg, position) {
    if (figureImg.complete) {
      const originalWidth = figureImg.width;
      const originalHeight = figureImg.height;
      const aspectRatio = originalWidth / originalHeight;

      // Apply scale factor to both width and height
      let figureWidth = originalWidth * figureScale;
      let figureHeight = originalHeight * figureScale;

      // Adjust position to center the figure at the click point
      let drawX = position.x - figureWidth / 2;
      let drawY = position.y - figureHeight / 2;

      // Adjust position to stay within canvas boundaries
      const adjustedPosition = adjustFigurePosition(drawX, drawY, figureWidth, figureHeight);
      drawX = adjustedPosition.drawX;
      drawY = adjustedPosition.drawY;

      // Update figurePosition based on adjusted drawX and drawY
      figurePosition.x = drawX + figureWidth / 2;
      figurePosition.y = drawY + figureHeight / 2;

      // Draw the figure
      ctx.drawImage(figureImg, drawX, drawY, figureWidth, figureHeight);
    } else {
      figureImg.onload = function() {
        drawFigure(ctx, figureImg, position);
      };
    }
  }

  function adjustFigurePosition(drawX, drawY, figureWidth, figureHeight) {
    const canvas = document.getElementById('imageCanvas');

    // Ensure the figure doesn't go beyond the canvas edges
    if (drawX < 0) {
      drawX = 0;
    }
    if (drawY < 0) {
      drawY = 0;
    }
    if (drawX + figureWidth > canvas.width) {
      drawX = canvas.width - figureWidth;
    }
    if (drawY + figureHeight > canvas.height) {
      drawY = canvas.height - figureHeight;
    }

    return { drawX, drawY };
  }

  function getLogoPosition(canvas, logoWidth, logoHeight) {
    const logoPosition = document.getElementById('logoPosition').value; // Get selected logo position
    let x, y;

    switch (logoPosition) {
      case 'top-left':
        x = 10;
        y = 10;
        break;
      case 'top-right':
        x = canvas.width - logoWidth - 10;
        y = 10;
        break;
      case 'bottom-left':
        x = 10;
        y = canvas.height - logoHeight - 10;
        break;
      case 'bottom-right':
        x = canvas.width - logoWidth - 10;
        y = canvas.height - logoHeight - 10;
        break;
      case 'center':
        x = (canvas.width - logoWidth) / 2;
        y = (canvas.height - logoHeight) / 2;
        break;
      default:
        x = 10; // Default to top-left if no position is selected
        y = 10;
    }

    return { x, y };
  }


  function drawLogo(ctx, logoImg) {
    // Similar drawing logic as before, but now it uses the logoImg provided
    if (logoImg) {
      let logoWidth = logoImg.width;
      let logoHeight = logoImg.height;
      const maxLogoWidth = 150;

      // Resize logo to a max width of 150px while maintaining aspect ratio
      if (logoWidth > maxLogoWidth) {
        const aspectRatio = logoWidth / logoHeight;
        logoWidth = maxLogoWidth;
        logoHeight = logoWidth / aspectRatio; // Adjust height based on aspect ratio
      }

      const { x, y } = getLogoPosition(ctx.canvas, logoWidth, logoHeight);

      ctx.drawImage(logoImg, x, y, logoWidth, logoHeight);
    }
  }

  // Add event listener for logo filter radio buttons
  document.querySelectorAll('input[name="logoFilter"]').forEach((radio) => {
    radio.addEventListener('change', function() {
      updateLogo(); // Function to only update the logo
    });
  });

  function updateLogo() {
    const ctx = canvas.getContext('2d');

    // Calculate logo size
    let logoWidth = logoImg.width;
    let logoHeight = logoImg.height;
    const maxLogoSize = 200;

    // Resize if necessary
    if (logoWidth > maxLogoSize || logoHeight > maxLogoSize) {
      const aspectRatio = logoWidth / logoHeight;
      if (logoWidth > logoHeight) {
        logoWidth = maxLogoSize;
        logoHeight = logoWidth / aspectRatio;
      } else {
        logoHeight = maxLogoSize;
        logoWidth = logoHeight * aspectRatio;
      }
    }

    // Get the position for the logo
    const { x, y } = getLogoPosition(canvas, logoWidth, logoHeight);

    // Clear previous logo area
    ctx.clearRect(x, y, logoWidth, logoHeight);

    // Draw the logo with the selected filter
    drawLogo(ctx, logoImg); // This will handle the drawing with the filter applied
  }

  // Add event listener for contrast range input
  document.getElementById('contrastRange').addEventListener('input', function() {
    contrastValue = parseInt(this.value); // Get the contrast value
    document.getElementById('contrastValue').innerText = contrastValue; // Update the display
    renderImageWithBlur(); // Re-render the image to apply contrast
  });

  // Listen for changes in the logo position and update the canvas immediately
  document.getElementById('logoPosition').addEventListener('change', function() {
    renderImageWithBlur();  // Update canvas when logo position changes
  });

  // Handle canvas click events depending on the current mode
  function handleCanvasClick(e) {
    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;

    // Calculate the position ratios relative to the canvas size
    const positionXRatio = mouseX / canvas.width;
    const positionYRatio = mouseY / canvas.height;

    if (mode === 'text') {
      // Store position ratios for text
      textPosition = { x: positionXRatio, y: positionYRatio };
      console.log(textPosition)
      renderImageWithBlur(); // Re-render the image with the updated text position
    } else if (mode === 'figure' && isFigureSelected) {
      // Store position ratios for figure
      figurePosition = { x: positionXRatio, y: positionYRatio };
      renderImageWithBlur(); // Re-render the image with the updated figure position
    }
  }


  // Handle mouse down for drawing blur area or moving text
  function handleMouseDown(e) {
    if (mode !== 'blur') return; // Only allow drawing in blur mode

    const rect = canvas.getBoundingClientRect();
    startX = e.clientX - rect.left;
    startY = e.clientY - rect.top;

    isDrawing = true;

    // Store the starting position ratios
    blurArea.x = startX / canvas.width;
    blurArea.y = startY / canvas.height;
    blurArea.width = 0;
    blurArea.height = 0;
  }


  function handleMouseMove(e) {
    if (!isDrawing) return;

    const ctx = canvas.getContext('2d');
    const rect = canvas.getBoundingClientRect();

    const currentX = e.clientX - rect.left;
    const currentY = e.clientY - rect.top;

    // Calculate the width and height in ratios
    blurArea.width = (currentX - startX) / canvas.width;
    blurArea.height = (currentY - startY) / canvas.height;

    renderImageWithBlur();

    // Draw the rectangle for visual feedback
    ctx.strokeStyle = 'red';
    ctx.lineWidth = 2;
    ctx.strokeRect(
      blurArea.x * canvas.width,
      blurArea.y * canvas.height,
      blurArea.width * canvas.width,
      blurArea.height * canvas.height
    );
  }

  function handleMouseUp(e) {
    if (isDrawing) {
      isDrawing = false;
      renderImageWithBlur();
    }
  }

  function isInsideBlurArea(x, y) {
    return x > blurArea.x && x < blurArea.x + blurArea.width &&
      y > blurArea.y && y < blurArea.y + blurArea.height;
  }

  // Attach event listeners to the canvas for text positioning and blur area drawing
  canvas.addEventListener('mousedown', handleMouseDown);
  canvas.addEventListener('mousemove', handleMouseMove);
  canvas.addEventListener('mouseup', handleMouseUp);
  canvas.addEventListener('click', handleCanvasClick);

  // Download button functionality
  document.getElementById('downloadButton').addEventListener('click', function() {
    const link = document.createElement('a');
    link.href = canvas.toDataURL('image/png');
    link.download = 'processed-image.png';
    link.click();
  });

</script>

</body>

</html>
