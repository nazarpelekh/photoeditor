<!doctype html>
<html class="no-js" lang="">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title></title>
  <link rel="stylesheet" href="css/style.css">
  <meta name="description" content="">

  <meta property="og:title" content="">
  <meta property="og:type" content="">
  <meta property="og:url" content="">
  <meta property="og:image" content="">

  <link rel="icon" href="/favicon.ico" sizes="any">
  <link rel="icon" href="/icon.svg" type="image/svg+xml">
  <link rel="apple-touch-icon" href="icon.png">

  <link rel="manifest" href="site.webmanifest">
  <meta name="theme-color" content="#fafafa">

  <!--<style>
    @font-face {
      font-family: 'Plus Jakarta Sans';
      src: url('/fonts/PlusJakartaSans-Regular.woff2') format('woff2'),
      url('/fonts/PlusJakartaSans-Regular.woff') format('woff');
      font-weight: normal;
      font-style: normal;
      font-display: swap;
    }

    @font-face {
      font-family: 'Plus Jakarta Sans';
      src: url('/fonts/PlusJakartaSans-BoldItalic.woff2') format('woff2'),
      url('/fonts/PlusJakartaSans-BoldItalic.woff') format('woff');
      font-weight: bold;
      font-style: italic;
      font-display: swap;
    }

    @font-face {
      font-family: 'Plus Jakarta Sans';
      src: url('/fonts/PlusJakartaSans-Bold.woff2') format('woff2'),
      url('/fonts/PlusJakartaSans-Bold.woff') format('woff');
      font-weight: bold;
      font-style: normal;
      font-display: swap;
    }

    @font-face {
      font-family: 'Plus Jakarta Sans';
      src: url('/fonts/PlusJakartaSans-Italic.woff2') format('woff2'),
      url('/fonts/PlusJakartaSans-Italic.woff') format('woff');
      font-weight: normal;
      font-style: italic;
      font-display: swap;
    }

    @font-face {
      font-family: 'Richmond Text';
      src: url('/fonts/RichmondText-Regular.woff2') format('woff2'),
      url('/fonts/RichmondText-Regular.woff') format('woff');
      font-weight: normal;
      font-style: normal;
      font-display: swap;
    }

    @font-face {
      font-family: 'Richmond Display';
      src: url('/fonts/RichmondDisplay-RegularItalic.woff2') format('woff2'),
      url('/fonts/RichmondDisplay-RegularItalic.woff') format('woff');
      font-weight: normal;
      font-style: italic;
      font-display: swap;
    }

    @font-face {
      font-family: 'Richmond Display';
      src: url('/fonts/RichmondDisplay-Bold.woff2') format('woff2'),
      url('/fonts/RichmondDisplay-Bold.woff') format('woff');
      font-weight: bold;
      font-style: normal;
      font-display: swap;
    }

    @font-face {
      font-family: 'Richmond Display';
      src: url('/fonts/RichmondDisplay-SemiBoldItalic.woff2') format('woff2'),
      url('/fonts/RichmondDisplay-SemiBoldItalic.woff') format('woff');
      font-weight: bold;
      font-style: italic;
      font-display: swap;
    }

    @font-face {
      font-family: 'Playfair Display';
      src: url('/fonts/PlayfairDisplay-BoldItalic.woff2') format('woff2'),
      url('/fonts/PlayfairDisplay-BoldItalic.woff') format('woff');
      font-weight: bold;
      font-style: italic;
      font-display: swap;
    }

    @font-face {
      font-family: 'Playfair Display';
      src: url('/fonts/PlayfairDisplay-Bold.woff2') format('woff2'),
      url('/fonts/PlayfairDisplay-Bold.woff') format('woff');
      font-weight: bold;
      font-style: normal;
      font-display: swap;
    }

    @font-face {
      font-family: 'Playfair Display';
      src: url('/fonts/PlayfairDisplay-Italic.woff2') format('woff2'),
      url('/fonts/PlayfairDisplay-Italic.woff') format('woff');
      font-weight: normal;
      font-style: italic;
      font-display: swap;
    }

    @font-face {
      font-family: 'Playfair Display';
      src: url('/fonts/PlayfairDisplay-Regular.woff2') format('woff2'),
      url('/fonts/PlayfairDisplay-Regular.woff') format('woff');
      font-weight: normal;
      font-style: normal;
      font-display: swap;
    }


  </style>-->

    <link href="https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@400;700&family=Playfair+Display:wght@400;700&family=Richmond+Display:wght@400&display=swap" rel="stylesheet">
</head>

<body>
<!-- Version 4 -->
<form id="imageForm">
  <input type="file" id="uploadImage" accept="image/*">
  <br><br>



  <!-- Mode selector for choosing between Text and Blur Area -->
  <label>
    <input type="radio" name="mode" value="text" checked> Text Mode
  </label>
  <label>
    <input type="radio" name="mode" value="blur"> Blur Area Mode
  </label>
  <label>
    <input type="radio" name="mode" value="logo"> Logo Mode
  </label>
  <br><br>

  <div id="text_mode" class="mode-elements">
    <!-- Input for font size -->
    <label for="fontSizeRange">Font Size:</label>
    <input type="range" id="fontSizeRange" min="10" max="100" value="30">
    &nbsp;
    <!-- Font color picker -->
    <label for="fontColor">Font Color:</label>
    <input type="color" id="fontColor" value="#ffffff">
    <br><br>

    <!-- Input for custom text -->
    <textarea id="customTextEditor"></textarea>
    <br><br>


  </div>

  <div id="image_mode" class="mode-elements" style="display: none">
    <label for="blurStrength">Blur Strength:</label>
    <input type="range" id="blurStrength" min="0" max="30" value="0">
    <br><br>

    <label for="contrastRange">Contrast:</label>
    <input type="range" id="contrastRange" min="-100" max="100" value="0">
    <span id="contrastValue">0</span>
    <br><br>

    <label>Select overlay images:</label>
    <br>
    <div style="display:flex; align-items: center; gap: 10px">
      <label>
        <input type="checkbox" name="overlayImage" value="image1">
        <img src="./img/GRAIN-1.jpg" width="20" height="20" alt="">
        <br>
        <input type="range" id="image1Opacity" min="0" max="100" value="20"> Opacity
      </label>
      <label>
        <input type="checkbox" name="overlayImage" value="image2">
        <img src="./img/GRAIN-2.jpg" width="20" height="20" alt="">
        <br>
        <input type="range" id="image2Opacity" min="0" max="100" value="20"> Opacity
      </label>
      <label>
        <input type="checkbox" name="overlayImage" value="image3">
        <img src="./img/GRAIN-3.jpg" width="20" height="20" alt="">
        <br>
        <input type="range" id="image3Opacity" min="0" max="100" value="20"> Opacity
      </label>
      <label>
        <input type="checkbox" name="overlayImage" value="image4">
        <img src="./img/GRADIENT.jpg" width="20" height="20" alt="">
        <br>
        <input type="range" id="image4Opacity" min="0" max="100" value="20"> Opacity
      </label>
      <label>
        <input type="checkbox" name="overlayImage" value="image5">
        <img src="./img/GRADIENT-1.jpg" width="20" height="20" alt="">
        <br>
        <input type="range" id="image5Opacity" min="0" max="100" value="20"> Opacity
      </label>
      <label>
        <input type="checkbox" name="overlayImage" value="image6">
        <img src="./img/GRADIENT-4.jpg" width="20" height="20" alt="">
        <br>
        <input type="range" id="image6Opacity" min="0" max="100" value="20"> Opacity
      </label>
    </div>
    <br><br>
  </div>

  <div id="logoElements" class="mode-elements" style="display:none;">
    <div>
      <h3>Select a Logo:</h3>
      <label>
        <input type="radio" name="staticLogo" value="noLogo" checked> NO LOGO
      </label>
      <label>
        <input type="radio" name="staticLogo" value="logo1"> Logo 1
      </label>
      <label>
        <input type="radio" name="staticLogo" value="logo2"> Logo 2
      </label>
      <label>
        <input type="radio" name="staticLogo" value="logo3"> Logo 3
      </label>
      <label>
        <input type="file" id="uploadLogo" accept="image/*"> Upload Custom Logo
      </label>
    </div>

    <br>

    <!-- Logo position selection -->
    <label for="logoPosition">Select Logo Position:</label>
    <select id="logoPosition">
      <option value="top-left">Top Left</option>
      <option value="top-right">Top Right</option>
      <option value="bottom-left">Bottom Left</option>
      <option value="bottom-right">Bottom Right</option>
      <option value="center">Center</option>
    </select>
    <br><br>
  </div>

  <canvas id="imageCanvas" style="display:none;"></canvas>
  <br>
  <button type="button" id="downloadButton" style="display:none;">Download Processed Image</button>
</form>

<script src="https://cdn.tiny.cloud/1/hw35wh74adbpr4x0uc9ngxdc8yxqbh0uazjhujo98kaqrou9/tinymce/7/tinymce.min.js" referrerpolicy="origin"></script>
<script>
  let img, overlayImg = new Image(), isDrawing = false, isResizing = false;
  let logoImg;
  let startX, startY, rectWidth, rectHeight;
  let blurArea = { x: 0, y: 0, width: 0, height: 0 };
  let textPosition = { x: 0, y: 0 }; // Position of the text
  let fontSize = 30; // Default font size
  let fontFamily = 'Arial'; // Default font family
  let fontColor = '#ffffff'; // Default font color
  let mode = 'text'; // Default mode is text positioning
  let overlayImageSelection = 'image1'; // Default overlay image
  let contrastValue = 0; // Default contrast value
  let logoFilter = 'colored'; // Default logo filter

  let overlayImages = {};  // Store overlay images here
  let overlayImageOpacity = { image1: 0.2, image2: 0.2, image3: 0.2, image4: 0.2, image5: 0.2, image6: 0.2 }; // Default opacity for each image
  let staticOverlayImages = {
    image1: './img/GRAIN-1.jpg',
    image2: './img/GRAIN-2.jpg',
    image3: './img/GRAIN-3.jpg',
    image4: './img/GRADIENT.jpg',
    image5: './img/GRADIENT-1.jpg',
    image6: './img/GRADIENT-4.jpg',
  }

  const staticLogos = {
    logo1: './img/logo.svg',
    logo2: './img/logo-black.svg',
    logo3: './img/logo-white.svg',
  }
  let uploadedLogo = null;


  // Add event listener for static logo selection
  document.querySelectorAll('input[name="staticLogo"]').forEach((radio) => {
    radio.addEventListener('change', function() {
      uploadedLogo = null; // Clear the uploaded logo when a static logo is selected
      renderImageWithBlur(); // Re-render the image
    });
  });

  // Handle the logo upload
  document.getElementById('uploadLogo').addEventListener('change', function(event) {
    const file = event.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = function(e) {
      uploadedLogo = new Image();
      uploadedLogo.onload = function() {
        // Reset static logo selection to "NO LOGO"
        document.querySelector('input[name="staticLogo"][value="noLogo"]').checked = true;
        renderImageWithBlur(); // Render the image with the uploaded logo
      };
      uploadedLogo.src = e.target.result;
    };
    reader.readAsDataURL(file);
  });


  // Handle the checkbox selections for overlay images
  document.querySelectorAll('input[name="overlayImage"]').forEach(checkbox => {
    checkbox.addEventListener('change', function() {
      const selectedImage = checkbox.value;

      if (checkbox.checked) {
        // Load the overlay image and store it in the overlayImages object
        const overlayImg = new Image();
        overlayImg.src = staticOverlayImages[selectedImage];
        overlayImg.onload = function() {
          overlayImages[selectedImage] = overlayImg;
          renderImageWithBlur();  // Re-render with the new overlay
        };
      } else {
        // Remove the image from the overlayImages object
        delete overlayImages[selectedImage];
        renderImageWithBlur();  // Re-render without the overlay
      }
    });
  });

  // Initialize TinyMCE
  tinymce.init({
    selector: '#customTextEditor',
    setup: function (editor) {
      editor.on('input change', function () {
        renderImageWithBlur();
      });
    },
    toolbar: 'undo redo | bold italic | fontfamily',
    menubar: false,
    font_family_formats: 'Arial=arial,helvetica,sans-serif; Plus Jakarta Sans=Plus Jakarta Sans, sans-serif; Richmond Display=Richmond Display, serif; Playfair Display=Playfair Display, serif;',
    default_font_stack: ['Arial'],
    height: 200,
  });

  // Handle checkbox selection for overlay images
  document.querySelectorAll('input[name="overlayImage"]').forEach((checkbox) => {
    checkbox.addEventListener('change', function() {
      renderImageWithBlur(); // Re-render the image when any checkbox is toggled
    });
  });

  function drawText(ctx) {
    // Get the HTML content from TinyMCE or the custom editor
    const customTextHTML = tinymce.get('customTextEditor').getContent();

    if (customTextHTML) {
      // Create a temporary DOM element to parse the HTML content
      const tempDiv = document.createElement('div');
      tempDiv.innerHTML = customTextHTML;

      // Extract and parse each child node (text, <b>, <i> tags, etc.)
      const nodes = tempDiv.childNodes;

      let x = textPosition.x;
      let y = textPosition.y;

      // Loop through all child nodes
      nodes.forEach(node => {
        if (node.nodeName === 'P') {
          // Handle <p> elements for block-level content
          handleParagraph(ctx, node, x, y);
          y += fontSize* 1.2; // Move to the next line after each paragraph
        } else {
          // Inline elements like <b>, <i>, <strong>, etc.
          handleInlineText(ctx, node, x, y);
        }
      });
      console.log(customTextHTML)
    }
  }

  // Function to handle paragraph <p> nodes
  function handleParagraph(ctx, node, x, y) {
    node.childNodes.forEach(childNode => {
      handleInlineText(ctx, childNode, x, y);
      x += ctx.measureText(childNode.textContent).width; // Adjust x position for inline elements
    });
  }

  // Function to handle inline elements (<b>, <i>, <strong>, etc.)
  function handleInlineText(ctx, node, x, y) {
    let fontStyle = '';

    // Determine the font style based on the element type
    if (node.nodeName === 'B' || node.nodeName === 'STRONG') {
      fontStyle = 'bold ';
    } else if (node.nodeName === 'I' || node.nodeName === 'EM') {
      fontStyle = 'italic ';
    }

    // Check if the node has a specific font family set via inline style
    if (node.style && node.style.fontFamily) {
      fontFamily = node.style.fontFamily;
    }

    // Set font and style for canvas rendering
    ctx.font = `${fontStyle}${fontSize}px ${fontFamily}`;
    ctx.fillStyle = fontColor;
    ctx.textAlign = 'left'; // Align left for better flow control

    // Draw the text based on node type (text or element)
    if (node.nodeType === Node.TEXT_NODE) {
      ctx.fillText(node.textContent, x, y);
    } else if (node.nodeType === Node.ELEMENT_NODE) {
      ctx.fillText(node.innerText, x, y);
    }
  }

  let staticImg = new Image();
  staticImg.src = 'https://placehold.co/600x600';

  // Load the uploaded image
  document.getElementById('uploadImage').addEventListener('change', function(event) {
    const file = event.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = function(e) {
      img = new Image();
      img.onload = function() {
        renderImageWithBlur(); // Initial rendering with the uploaded image and static image overlay
      };
      img.src = e.target.result;
    };
    reader.readAsDataURL(file);
  });

  document.getElementById('fontSizeRange').addEventListener('input', function() {
    fontSize = parseInt(this.value);
    renderImageWithBlur(); // Re-render the image to apply new font size
  });

  document.getElementById('fontColor').addEventListener('input', function() {
    fontColor = this.value;
    renderImageWithBlur(); // Re-render the image to apply new font color
  });

  // Get references to mode radio buttons and the elements to show/hide
  const modeRadios = document.querySelectorAll('input[name="mode"]');
  const textElements = document.getElementById('text_mode');
  const blurElements = document.getElementById('image_mode');
  const logoElements = document.getElementById('logoElements')

  // Function to update the visibility of elements based on the active mode
  function updateVisibility() {
    const activeMode = document.querySelector('input[name="mode"]:checked').value;

    if (activeMode === 'text') {
      textElements.style.display = 'block';
      blurElements.style.display = 'none';
      logoElements.style.display = 'none';
    } else if (activeMode === 'blur') {
      textElements.style.display = 'none';
      blurElements.style.display = 'block';
      logoElements.style.display = 'none';
    } else if (activeMode === 'logo') {
      textElements.style.display = 'none';
      blurElements.style.display = 'none';
      logoElements.style.display = 'block';
    }
  }

  // Add event listeners to the mode radio buttons
  modeRadios.forEach(radio => {
    radio.addEventListener('change', updateVisibility);
  });

  // Call the function initially to set the correct visibility when the page loads
  updateVisibility();

  // Mode switcher for toggling between text positioning and blur area mode
  document.querySelectorAll('input[name="mode"]').forEach((radio) => {
    radio.addEventListener('change', function() {
      mode = this.value; // Update the mode based on user selection
    });
  });

  // Handle overlay image selection
  document.querySelectorAll('input[name="overlayImage"]').forEach((radio) => {
    radio.addEventListener('change', function() {
      overlayImageSelection = this.value; // Update the selected image type
      overlayImg.src = overlayImages[overlayImageSelection]; // Load the selected image
      overlayImg.onload = function() {
        renderImageWithBlur(); // Re-render the image with the new overlay
      };
    });
  });

  let blurStrength = 0; // Default blur strength (10px)

  // Capture the value from the blur range input and update the blur strength dynamically
  document.getElementById('blurStrength').addEventListener('input', function() {
    blurStrength = parseInt(this.value); // Update the blur strength based on the range input
    renderImageWithBlur(); // Re-render the canvas with the new blur strength
  });

  // Handle opacity sliders for each overlay image
  document.querySelectorAll('input[type="range"]').forEach(slider => {
    slider.addEventListener('input', function() {
      const imageName = this.id.replace('Opacity', '');
      const opacityValue = parseInt(this.value) / 100;  // Convert to opacity range 0-1
      overlayImageOpacity[imageName] = opacityValue;  // Store the opacity value
      renderImageWithBlur();  // Re-render with updated opacity
    });
  });

  // Function to render the image with a blur, clear area, overlay image, and text
  function renderImageWithBlur() {
    const canvas = document.getElementById('imageCanvas');
    const ctx = canvas.getContext('2d');

    // Scale the image if larger than 800px
    let scaleFactor = 1;
    if (img.width > 800 || img.height > 800) {
      scaleFactor = Math.min(800 / img.width, 800 / img.height);
    }

    const canvasWidth = img.width * scaleFactor;
    const canvasHeight = img.height * scaleFactor;

    canvas.width = canvasWidth;
    canvas.height = canvasHeight;

    // Clear the canvas
    ctx.clearRect(0, 0, canvasWidth, canvasHeight);

    // 1. Draw the uploaded image to the canvas (scaled)
    // ctx.drawImage(img, 0, 0, canvasWidth, canvasHeight);

    ctx.filter = `blur(${blurStrength}px)`;  // Apply blur based on user input
    ctx.filter += ` contrast(${100 + contrastValue}%)`;
    ctx.drawImage(img, 0, 0, canvasWidth, canvasHeight);  // Blur with shifted and expanded size
    ctx.filter = 'none'; // Reset the filter

    // 3. Restore the unblurred region, if specified
    if (blurArea.width > 0 && blurArea.height > 0) {
      // Redraw the unblurred part of the image
      ctx.filter = ` contrast(${100 + contrastValue}%)`;
      ctx.drawImage(
        img,
        blurArea.x / scaleFactor,        // Source X (same as unblurred area)
        blurArea.y / scaleFactor,        // Source Y (same as unblurred area)
        blurArea.width / scaleFactor,    // Source width (exact size, no blur offset)
        blurArea.height / scaleFactor,   // Source height (exact size, no blur offset)
        blurArea.x,                 // Destination X (shifted -20px to the left)
        blurArea.y,                 // Destination Y (shifted -20px up)
        blurArea.width,             // Destination width (increased by 40px)
        blurArea.height,
        contrastValue
      );
      ctx.filter = 'none'; // Reset the filter
    }

    // 4. Draw the selected overlay images with their respective opacities
    for (let key in overlayImages) {
      const overlayImg = overlayImages[key];
      const opacity = overlayImageOpacity[key];  // Get the opacity for the current image
      ctx.globalAlpha = opacity;  // Apply the opacity
      ctx.drawImage(overlayImg, 0, 0, canvasWidth, canvasHeight);
      ctx.globalAlpha = 1;  // Reset the opacity
    }

    // 5. Draw the uploaded logo at the selected position
    if (uploadedLogo) {
      drawLogo(ctx, uploadedLogo);
    } else {
      const selectedLogoKey = document.querySelector('input[name="staticLogo"]:checked').value;
      if (selectedLogoKey !== 'noLogo') {
        let selectedLogoSrc = staticLogos[selectedLogoKey];
        const staticLogo = new Image();
        staticLogo.onload = function() {
          drawLogo(ctx, staticLogo);
        };
        staticLogo.src = selectedLogoSrc;
      }
    }

    // 6. Draw the custom text at the selected position
    drawText(ctx);

    // 7. Display the canvas and download button
    canvas.style.display = 'block';
    document.getElementById('downloadButton').style.display = 'block';
  }

  function getLogoPosition(canvas, logoWidth, logoHeight) {
    const logoPosition = document.getElementById('logoPosition').value; // Get selected logo position
    let x, y;

    switch (logoPosition) {
      case 'top-left':
        x = 10;
        y = 10;
        break;
      case 'top-right':
        x = canvas.width - logoWidth - 10;
        y = 10;
        break;
      case 'bottom-left':
        x = 10;
        y = canvas.height - logoHeight - 10;
        break;
      case 'bottom-right':
        x = canvas.width - logoWidth - 10;
        y = canvas.height - logoHeight - 10;
        break;
      case 'center':
        x = (canvas.width - logoWidth) / 2;
        y = (canvas.height - logoHeight) / 2;
        break;
      default:
        x = 10; // Default to top-left if no position is selected
        y = 10;
    }

    return { x, y };
  }

  function drawLogo(ctx, logoImg) {
    // Similar drawing logic as before, but now it uses the logoImg provided
    if (logoImg) {
      let logoWidth = logoImg.width;
      let logoHeight = logoImg.height;
      const maxLogoWidth = 150;

      // Resize logo to a max width of 150px while maintaining aspect ratio
      if (logoWidth > maxLogoWidth) {
        const aspectRatio = logoWidth / logoHeight;
        logoWidth = maxLogoWidth;
        logoHeight = logoWidth / aspectRatio; // Adjust height based on aspect ratio
      }

      const { x, y } = getLogoPosition(ctx.canvas, logoWidth, logoHeight);

      ctx.drawImage(logoImg, x, y, logoWidth, logoHeight);
    }
  }

  // Add event listener for logo filter radio buttons
  document.querySelectorAll('input[name="logoFilter"]').forEach((radio) => {
    radio.addEventListener('change', function() {
      updateLogo(); // Function to only update the logo
    });
  });

  function updateLogo() {
    const canvas = document.getElementById('imageCanvas');
    const ctx = canvas.getContext('2d');

    // Calculate logo size
    let logoWidth = logoImg.width;
    let logoHeight = logoImg.height;
    const maxLogoSize = 200;

    // Resize if necessary
    if (logoWidth > maxLogoSize || logoHeight > maxLogoSize) {
      const aspectRatio = logoWidth / logoHeight;
      if (logoWidth > logoHeight) {
        logoWidth = maxLogoSize;
        logoHeight = logoWidth / aspectRatio;
      } else {
        logoHeight = maxLogoSize;
        logoWidth = logoHeight * aspectRatio;
      }
    }

    // Get the position for the logo
    const { x, y } = getLogoPosition(canvas, logoWidth, logoHeight);

    // Clear previous logo area
    ctx.clearRect(x, y, logoWidth, logoHeight);

    // Draw the logo with the selected filter
    drawLogo(ctx, logoImg); // This will handle the drawing with the filter applied
  }

  // Add event listener for contrast range input
  document.getElementById('contrastRange').addEventListener('input', function() {
    contrastValue = parseInt(this.value); // Get the contrast value
    document.getElementById('contrastValue').innerText = contrastValue; // Update the display
    renderImageWithBlur(); // Re-render the image to apply contrast
  });

  // Listen for changes in the logo position and update the canvas immediately
  document.getElementById('logoPosition').addEventListener('change', function() {
    renderImageWithBlur();  // Update canvas when logo position changes
  });

  // Handle canvas click events depending on the current mode
  function handleCanvasClick(e) {
    const canvas = document.getElementById('imageCanvas');
    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;

    if (mode === 'text') {
      // Set text position when in text mode
      textPosition.x = mouseX;
      textPosition.y = mouseY;
      renderImageWithBlur(); // Re-render the image with the updated text position
    }
  }

  // Handle mouse down for drawing blur area or moving text
  function handleMouseDown(e) {
    if (mode !== 'blur') return; // Only allow drawing in blur mode

    const canvas = document.getElementById('imageCanvas');
    const rect = canvas.getBoundingClientRect();
    startX = e.clientX - rect.left;
    startY = e.clientY - rect.top;

    if (isInsideBlurArea(startX, startY)) {
      isResizing = true; // If inside the blur area, resize it
    } else {
      isDrawing = true; // Otherwise, draw a new area
    }
  }

  function handleMouseMove(e) {
    if (!isDrawing && !isResizing) return;

    const canvas = document.getElementById('imageCanvas');
    const ctx = canvas.getContext('2d');
    const rect = canvas.getBoundingClientRect();

    const currentX = e.clientX - rect.left;
    const currentY = e.clientY - rect.top;

    if (isDrawing) {
      rectWidth = currentX - startX;
      rectHeight = currentY - startY;

      // Redraw the image and blur
      renderImageWithBlur();

      // Draw the rectangle for the clear area
      ctx.strokeStyle = 'red';
      ctx.lineWidth = 2;
      ctx.strokeRect(startX, startY, rectWidth, rectHeight);
    } else if (isResizing) {
      rectWidth = currentX - blurArea.x;
      rectHeight = currentY - blurArea.y;

      renderImageWithBlur();
      ctx.strokeStyle = 'red';
      ctx.lineWidth = 2;
      ctx.strokeRect(blurArea.x, blurArea.y, rectWidth, rectHeight);
    }
  }

  function handleMouseUp(e) {
    if (isDrawing) {
      isDrawing = false;

      blurArea.x = startX;
      blurArea.y = startY;
      blurArea.width = rectWidth;
      blurArea.height = rectHeight;

      renderImageWithBlur();
    } else if (isResizing) {
      isResizing = false;

      blurArea.width = rectWidth;
      blurArea.height = rectHeight;

      renderImageWithBlur();
    }
  }

  function isInsideBlurArea(x, y) {
    return x > blurArea.x && x < blurArea.x + blurArea.width &&
      y > blurArea.y && y < blurArea.y + blurArea.height;
  }

  // Attach event listeners to the canvas for text positioning and blur area drawing
  const canvas = document.getElementById('imageCanvas');
  canvas.addEventListener('mousedown', handleMouseDown);
  canvas.addEventListener('mousemove', handleMouseMove);
  canvas.addEventListener('mouseup', handleMouseUp);
  canvas.addEventListener('click', handleCanvasClick);

  // Download button functionality
  document.getElementById('downloadButton').addEventListener('click', function() {
    const canvas = document.getElementById('imageCanvas');
    const link = document.createElement('a');
    link.href = canvas.toDataURL('image/png');
    link.download = 'processed-image.png';
    link.click();
  });

</script>

</body>

</html>
